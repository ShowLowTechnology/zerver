{"name":"Zerver","tagline":"modern html5 webapp server","body":"Zerver is a lightweight Node.js-based webserver that lets you seamlessly make server API calls as if they were a library on the client. The goal is to provide a developer-focused toolset and remove all the boilerplate involved in serving a webapp.\r\n\r\n## Install\r\n\r\n```sh\r\nnpm install -g zerver\r\n# or add zerver to your package.json dependencies and run npm install\r\n```\r\n\r\n\r\n\r\n# Basic usage\r\n\r\nLet's say you have a directory of this structure.\r\n\r\n```\r\nwebsite-dir/index.html\r\nwebsite-dir/zerver/MyAPI.js\r\n```\r\n\r\nEverything in `website-dir` will be served as static content except for code in `zerver/` which will run on the server.\r\nOnly files on the topmost level of the zerver folder will be saved as api's i.e. files in subfolders under zerver will not be used unless they are specifically required in one of the main api files.\r\n```js\r\n// in website-dir/zerver/MyAPI.js\r\n// this runs on the server\r\nexports.logStuff = function (str) {\r\n    console.log(str); // 'hi from client'\r\n    callback('hi from server');\r\n};\r\n```\r\n\r\n```html\r\n<!-- in website-dir/index.html -->\r\n<!-- this runs in the browser -->\r\n<script src=\"zerver/MyAPI.js\"></script>\r\n<script>\r\n    MyAPI.logStuff('hi from client', function (str) {\r\n        console.log(str); // \"hi from server\"\r\n    });\r\n</script>\r\n```\r\n\r\n```sh\r\n# run the server\r\nzerver website-dir\r\n# go to http://localhost:5000/ to view the magic\r\n```\r\n\r\n### What just happened?\r\n\r\n`MyAPI.logStuff` automatically serializes the arguments of the function call and makes an AJAX request to the server. The server runs the function in `website-dir/zerver/MyAPI.js` and responds to the client in a similar way.\r\n\r\nAny amount of arguments can be used in the function calls as long as they are JSON stringify-able (with the exception of the callback function).\r\n\r\nNote: any server code in a subdirectory of `website-dir/zerver` will not be available for import on the client allowing for libraries of private server functionality.\r\n\r\n\r\n\r\n# Zerver options\r\n\r\n```sh\r\n# General usage\r\nzerver [options] website-dir\r\n\r\n# run server on a different port\r\nzerver --port=8000 website-dir\r\n\r\n-V, --verbose\r\n# Verbose logging of requests, including host,\r\n# protocol, referrer, ip address and user agent\r\n\r\n-H, --headers\r\n# Include request headers in logging\r\n\r\n-j, --json\r\n# Print request logs as JSON (easy to consume by log parsers)\r\n```\r\n\r\n### Default options\r\n\r\nYou can specify default options in an environment variable, to avoid having to type them every time or having different setups for different environments in which the code will run:\r\n```sh\r\nexport ZERVER_FLAGS='-rc'\r\n```\r\n\r\n## Refresh mode (`-r, --refresh`)\r\n\r\n```sh\r\nzerver -r website-dir\r\n```\r\n\r\nWhen you are developing a webpage in the browser the `-r` flag causes the page to automatically refresh whenever you edit your code. This is a convenient utility that allows for frictionless rapid iteration.\r\n\r\nNote: this feature requires that you have included a zerver script somewhere on the webpage and that the browser supports websockets.\r\n\r\n## Command line interface (`-c, --cli`)\r\n\r\n```sh\r\nzerver -c website-dir\r\n```\r\n\r\nEnable command line JavaScript access to the browser that your webpage is currently running on. This is extremely usefull when running on a mobile device where it is difficult to debug and access logs. Right from your terminal you'll be able to run commands remotely and see their result as well as see a constant stream of logs from your client.\r\n\r\nFor example:\r\n\r\n```sh\r\n>>> zerver --cli website-dir\r\n\r\n# Press <tab> to access remote command line\r\n>>>\r\n# The following line logs all the functions that are available in 'MyAPI'\r\n>>> Object.keys(MyAPI)\r\n[\"function1\", \"function2\"]\r\n\r\n# Logs are automatically streamed here as well\r\n>>> console.log( Object.keys(MyAPI) )\r\nlog: [\"function1\", \"function2\"]\r\nundefined\r\n# Notice that the log occurred, as well as\r\n# the 'undefined' return value from the command\r\n```\r\n\r\nNote: this feature requires that you have included a zerver script somewhere on the webpage and that the browser supports websockets.\r\n\r\n## Production mode (`-p, --production`)\r\n\r\n```sh\r\nzerver -p website-dir\r\n```\r\n\r\nWhile zerver tries to provide the best developer experience it is built with production environments in mind. Enabling production mode turns on a list of features including:\r\n\r\n* in-memory caching of static files\r\n* auto compiled/minified JavaScript & CSS\r\n* gzipped output\r\n* inlined scripts, styles, images\r\n* concatenated scripts, styles\r\n* HTML5 appcache manifest management\r\n\r\n\r\n\r\n### Inline scripts, styles, images\r\n\r\nZerver can automatically inline files to reduce the number of requests your app makes and protentially speed things up for your users.\r\n\r\n```html\r\n<link rel=\"stylesheet\" href=\"/css/styles.css?inline=1\">\r\n<!-- will create a 'style' tag with the inlined css -->\r\n```\r\n\r\n```html\r\n<script src=\"/js/main.js?inline=1\"></script>\r\n<!-- will create a 'script' tag with the inlined js -->\r\n```\r\n\r\n```css\r\n#thing {\r\n    background-image: url(/img/background.png?inline=1);\r\n    /* will inline the image as a base64 data URI */\r\n}\r\n```\r\n\r\n### Concatenate scripts, styles\r\n\r\nThe reduce the number of requests your app makes it often makes sense to combine stylesheets or scripts into single files.\r\n\r\n```html\r\n<!-- zerver:css/main.min.css -->\r\n<link rel=\"stylesheet\" href=\"/css/jquery.ui.css\">\r\n<link rel=\"stylesheet\" href=\"/css/styles.css\">\r\n<!-- /zerver -->\r\n<!-- will create a 'link' tag with href=\"css/main.min.css\" -->\r\n```\r\n\r\n```html\r\n<!-- zerver:js/main.min.js -->\r\n<script src=\"js/jquery.js\"></script>\r\n<script src=\"js/jquery.ui.js\"></script>\r\n<script src=\"js/main.js\"></script>\r\n<!-- /zerver -->\r\n<!-- will create a 'script' tag with src=\"js/main.min.js\" -->\r\n```\r\n\r\nZerver will automatically serve the combined files at the designated URL.\r\n\r\n### HTML5 appcache manifest\r\n\r\nHTML5 has support for offline apps using [appcache manifests](http://diveintohtml5.info/offline.html). Apps using appcache will update when the manifest itself changes in some way so it is convenient to have the file change whenever there is an update to your client-side code, allowing users to always get the up-to-date version.\r\n\r\nZerver will automatically detect these manifest files and insure they update on file changes by appending a comment at the end with the timestamp that the client-side code last changed. This fixes one of the major drawbacks of having to manually manage an appcache manifest.\r\n\r\nIf files that are inlined or concatenated are included in the manifest then they should be marked appropriately:\r\n\r\n```appcache\r\nCACHE MANIFEST\r\n\r\n/img/background.png?inline=1\r\n\r\n# zerver:js/main.min.js\r\n/js/jquery.js\r\n/js/jquery.ui.js\r\n/js/main.js\r\n# /zerver\r\n\r\nNETWORK:\r\n*\r\n```\r\n\r\n\r\n\r\n# Server side\r\n\r\n### Custom API calls\r\n\r\nZerver allows you server custom API in a more tradional manner:\r\n\r\n```js\r\n/* in zerver/custom.js */\r\nexports.doSomething = doSomething;\r\n\r\ndoSomething.type = 'GET';\r\nfunction doSomething(params, callback) {\r\n    callback({ thing: params.stuff });\r\n}\r\n```\r\n\r\n```sh\r\n> curl -s \"localhost:5000/zerver/custom/doSomething?stuff=wat\"\r\n{ \"thing\" : \"wat\" }\r\n```\r\n\r\nIn this case the HTTP status was automaticallys set to 200 and JSON was served.\r\n\r\nResponse status code, headers and body can all be set manually as well:\r\n\r\n```js\r\ndoSomething.type = 'GET';\r\nfunction doSomething(params, callback) {\r\n    var status = 301;\r\n    var headers = {\r\n        'Location': '/zerver/custom/somethingElse'\r\n    };\r\n    var body = 'Moved permanently';\r\n    callback(status, headers, body);\r\n}\r\n```\r\n\r\nSome API resources make available multiple HTTP methods:\r\n\r\n```js\r\ndoSomething.type = ['GET', 'PUT', 'DELETE'];\r\nfunction doSomething(params, callback) {\r\n    if (this.method === 'GET') {\r\n        // get the resource\r\n    } else if (this.method === 'PUT') {\r\n        // update the resource\r\n    } else if (this.method === 'DELETE') {\r\n        // delete the resource\r\n    }\r\n}\r\n```\r\n\r\nThe 'this' context for API calls is the raw request object. Several additonal properties are added onto the object for convenience:\r\n\r\n```js\r\ndoSomething.type = 'POST';\r\nfunction doSomething(params, callback) {\r\n    this.ip        // client IP address\r\n    this.protocol  // request protocol (http, https)\r\n    this.host      // the hostname of the request (mysite.com)\r\n    this.pathname  // the exact resource (/zerver/custom/doSomething)\r\n    this.query     // a JSON object representation of URL query parameters\r\n    this.referrer  // the URL that referred the client to this resource\r\n    this.userAgent // the user agent string of the client\r\n\r\n    // for POST and PUT requests\r\n    this.body      // HTTP body as a string\r\n    this.jsonBody  // parsed body if HTTP body is JSON\r\n    this.formBody  // parsed body if HTTP body is form-encoded\r\n}\r\n```\r\n\r\nSince incoming parameters come in various forms the `params` object serves as a convenient place to access them. The `params` object is a combination of URL query parameters and JSON or form-encoded HTTP body parameters.\r\n\r\nReading and setting cookies is simple as well:\r\n\r\n```js\r\ndoSomething.type = 'POST';\r\nfunction doSomething(params, callback) {\r\n    var value = this.cookies.get('cookieName');\r\n    this.cookies.set('cookieName', 'otherValue');\r\n\r\n    // robust cookie set\r\n    this.cookies.set('cookieName', 'otherValue', {\r\n        maxAge   : 365*24*60*60,\r\n        expires  : new Date(2020, 8, 13),\r\n        domain   : 'mysite.com',\r\n        path     : '/zerver/custom',\r\n        httpOnly : true,\r\n        secure   : true,\r\n    });\r\n}\r\n```\r\n\r\n### Cross origin requests\r\n\r\nEnabling cross origin requests in zerver is a one-liner:\r\n\r\n```js\r\nexports._cors = 'mywebsite.com, myothersite.com';\r\n```\r\n\r\nFor this zerver module all API requests will respond properly to OPTIONS calls as well as serve access control headers when the API calls are made.\r\n\r\nTo allow all cross origin requests:\r\n\r\n```js\r\nexports._cors = '*';\r\n```\r\n\r\n\r\n\r\n# Client side\r\n\r\n### Require syntax\r\n\r\n```html\r\n<!-- in website-dir/index.html -->\r\n<script src=\"/zerver/require.js\"></script>\r\n<script>\r\n    var MyAPI = zerver.require('MyAPI');\r\n    MyAPI.logStuff('hi from client', function (str) {\r\n        console.log(str); // \"hi from server\"\r\n    });\r\n</script>\r\n```\r\n\r\n### Error handling\r\n\r\n```html\r\n<!-- in website-dir/index.html -->\r\n<script src=\"zerver/MyAPI.js\"></script>\r\n<script>\r\n    MyAPI.logStuff('hi from client', function (str) {\r\n        // this === MyAPI\r\n        console.log(str); // \"hi from server\"\r\n    }).error(function (err) {\r\n        // this === MyAPI\r\n        console.log(err); // error string explaining failure\r\n    });\r\n</script>\r\n```\r\n\r\n### Custom API calls\r\n\r\nZerver's client-side code packs in a convenient interface for making custom API calls.\r\n\r\n```js\r\n/* in website-dir/zerver/custom.js */\r\nexports.updateData = updateData;\r\n\r\nupdateData.type = 'POST';\r\nfunction updateData(params, callback) {\r\n    // params.data == { random: 'json' }\r\n    callback({ success: true });\r\n}\r\n```\r\n\r\n```html\r\n<!-- in website-dir/index.html -->\r\n<script src=\"zerver/require.js\"></script>\r\n<script>\r\n    zerver.post('custom/updateData', {\r\n        data: { random: 'json' }\r\n    }, function (response, raw, status) {\r\n        // response.success === true\r\n        // raw === '{\"success\":true}'\r\n        // status === 200\r\n    });\r\n</script>\r\n```\r\n\r\n`zerver.get`, `zerver.post`, `zerver.put` and `zerver.del` are all defined corresponding to their HTTP methods.\r\n\r\nThe second argument of API calls is the data to be passed to the server. This can be a raw string or a JSON object. For `POST` and `PUT` requests the data will be passed in the HTTP body, while all other requests will convert them into query string parameters.\r\n\r\nAPI calls can be made to any service (not necessary zerver):\r\n\r\n```js\r\nzerver.get('http://api.mysite.com/data.json', function (response) {\r\n    // do something with 'response'\r\n});\r\n```\r\n\r\nIf you're making repeated API calls to another service it's often convenient to not have to include the host prefix:\r\n\r\n```js\r\nzerver.prefix = 'http://api.mysite.com/';\r\nzerver.get('data.json', function (response) {\r\n    // do something with 'response'\r\n});\r\nzerver.get('otherdata.json', function (response) {\r\n    // do something with 'response'\r\n});\r\n```\r\n\r\n\r\n\r\n# ExpressJS integration\r\n\r\nZerver can be integrated with Express and other NodeJS servers to provide zerver APIs.\r\n\r\nHere is an example Express app:\r\n\r\n```\r\nwebsite-dir/app.js\r\nwebsite-dir/src/index.html\r\nwebsite-dir/zerver/MyAPI.js\r\n```\r\n\r\n```js\r\n/* app.js */\r\n\r\nvar express = require('express');\r\nvar zerver  = require('zerver');\r\n\r\nvar app = express();\r\napp.use( zerver.middleware(__dirname) );\r\napp.use( express.static(__dirname + '/src') );\r\napp.listen(3000);\r\n```\r\n\r\nAlong with the rest of the Express app, zerver scripts will be accessible for importing into the client-side code.\r\n\r\n\r\n\r\n# Example apps\r\n\r\n[Basic app](https://github.com/jairajs89/zerver/tree/master/examples/basic-app)\r\n\r\n[Express app](https://github.com/jairajs89/zerver/tree/master/examples/express-app)\r\n","google":"UA-4073712-12","note":"Don't delete this file! It's used internally to help with page regeneration."}